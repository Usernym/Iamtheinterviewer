<!doctype html>
	<html lang="en">
	  <head>
	    <meta charset="utf-8">
	    <title>About Me</title>
	  </head>
		
		
	<style>
		
.border { 
    width: auto; 
    height:auto;
    border: 10px solid transparent; 
    border-image: linear-gradient(to right, black, lightgreen); 
    border-image-slice: 1; 
    padding: 5px; 
} 

	#cool{
	font-weight: bold;
		}

   	a:hover{
	  color:rgb(255,255,255);
	  font-weight: bold;
	  }
	.op{
	font-family: fantasy;
	color: rgb(0,0,0);
	}
	
	.button {
        background-color:rgb(0, 0, 0);
        border: none;
        color: white;
        padding: 2px 16px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 21px;
        margin: 4px 3px;
        cursor:crosshair;
	font-family:fantasy;
    	border-radius:3px;
     	 }	
		
		</style>
		
	  <body bgcolor="#e7ff87">
		  <div class = "border">
	  
    			  <br></br>
	def decide(state):
    """
    Your algorithm to select participants for interviews.
    
    Args:
        state: SimulationState with current information
            - state.time: current time (0-500)
            - state.participants: list of all Participant objects
            - state.sent_at: dict of {participant_id: time_sent}
            - state.accepted: set of participant_ids who accepted
            - state.target_interviews: always 50
    
    Returns:
        {"toSend": ["u0", "u5", ...], "toCancel": ["u3", ...]}
    """
    to_send = []
    to_cancel = []
    
    # Strategy: Send in waves to ensure we reach 50 acceptances
    # Wave 1: 150 participants at t=0 (expect ~40 acceptances)
    # Wave 2: 100 more at t=20 if needed
    # Wave 3: 150 more at t=50 if still short
    
    if state.time == 0:
        unsent = [p for p in state.participants 
                 if p.id not in state.sent_at]
        unsent.sort(key=lambda p: p.relevance, reverse=True)
        to_send = [p.id for p in unsent[:150]]
    
    elif state.time == 20 and len(state.accepted) < state.target_interviews:
        unsent = [p for p in state.participants 
                 if p.id not in state.sent_at and p.id not in state.accepted]
        unsent.sort(key=lambda p: p.relevance, reverse=True)
        to_send = [p.id for p in unsent[:100]]
    
    elif state.time == 50 and len(state.accepted) < state.target_interviews:
        unsent = [p for p in state.participants 
                 if p.id not in state.sent_at and p.id not in state.accepted]
        unsent.sort(key=lambda p: p.relevance, reverse=True)
        to_send = [p.id for p in unsent[:150]]
    
    print(to_Send)
    return {"toSend": to_send, "toCancel": to_cancel}
()
	  

	  </body>
	</html>

